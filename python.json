{
	"write list to file": {
        "prefix": ["write list to txt, write list, write to file, write txt"],
        "body": [
            "# write list to file",
            "f = open('${1:filename here}', 'w')",
            "f.writelines(str(${0:list here}))",
            "f.close()"
        ]
    },
	"read txt file line by line": {
        "prefix": "read file, read txt file, read txt lines, read txt file line by line",
        "body": [
            "# read file line by line",
            "f = open('${1:filename here}', 'r')",
            "lineCount = 0",
            "while True:",
            "\tline = f.readline()",
            "\tif not line:",
            "\t\tbreak",
            "\tlineCount += 1",
            "\t#####################################################",
            "\t${0: further code here}",
            "\t#####################################################",
            "f.close()"
        ]
    },
	"import json in dict": {
        "prefix": "import json, import json in dict, read json file, read json in dict",
        "body": [
            "# import json and print keys and values",
            "import json",
            "f = open('${1:filename here}', 'r')",
            "dict = json.load(f)",
            "",
            "print(list(dict.keys()))",
            "print(list(dict.values()))",
            "",
            "f.close()"
        ]
    },
	"write dict to json file": {
        "prefix": "write dict to json file, write json file, write json, write dictionary",
        "body": [
            "# write dict to json file",
            "import json",
            "with open(\"${1:json filename here}\", \"w\") as f:",
            "\tjson.dump(${0:dict variable here}, f)"
        ]
    },
	"read csv file in list": {
        "prefix": "read csv file in list, read csv file, read csv, read csv file to list",
        "body": [
            "# read csv file into list",
            "import csv",
            "with open('${1:csv filename here}') as f:",
            "\tl1 = list(csv.reader(f))",
            "\tprint(l1)"
        ]
    },
	"write 1d list to csv file": {
        "prefix": "write 1d list, write 1d list to csv, write list to csv, write list to csv file, write list",
        "body": [
            "# write 1d list to csv file",
            "import csv",
            "f = open('${1:csv filename here}', 'a+', newline ='')",
            "with f:\t",
            "\twrite = csv.writer(f)",
            "\twrite.writerow(${0:1d list here})"
        ]
    },
	"write 2d list to csv file": {
        "prefix": "write 2d list to csv, write 2d list, write 2d list, write list to csv, write 2d list to csv file",
        "body": [
            "# write 2d list to csv file",
            "import csv",
            "f = open('${1:csv filename here}', 'a+', newline ='')",
            "with f:\t",
            "\twrite = csv.writer(f)",
            "\twrite.writerows(${0:2d list here})"
        ]
    },
	"create class with two variables": {
        "prefix": "create class, create parent class, create class with 1 static and 1 non-static variable, parent class",
        "body": [
            "# parent class, class with two methods,",
            "class c1:",
            "\ta1 = 0",
            "\ta2 = 0",
            " ",
            "\tdef __init__(self, a1, a2):",
            "\t\tc1.a1 = a1\t\t ",
            "\t\tself.a2 = a2\t   ",
            " ",
            "\tdef m1(self, b1):\t  ",
            "\t\tprint(b1)"
        ]
    },
	"create child class with two variables": {
        "prefix": "create child, create child class, child class, create child class with 1 non-static and 1 static variable",
        "body": [
            "# child class, class with two methods,",
            "class c2(${1:parent classname here}):",
            "\ta1 = 0",
            "\ta2 = 0",
            "",
            "\tdef __init__(self, a1, a2):",
            "\t\t${0:parent classname here}.__init__()",
            "\t\tc2.a1 = a1\t\t   ",
            "\t\tself.a2 = a2\t\t ",
            "\t",
            "\tdef m1(self, a1):\t\t",
            "\t\tprint(a1)"
        ]
    },
	"create object of class": {
        "prefix": "create object, obj, create object of class, create object with two arguments",
        "body": [
            "# instantiate parent class, object creation",
            "obj1 = ${1:classname here}(a1,a2)",
            ""
        ]
    },
	"stack class": {
        "prefix": "stack, create stack, stack class, create stack class, create stack object, stack object",
        "body": [
            "# implementing stack",
            "from collections import deque",
            "",
            "# close this class from side",
            "class stack:",
            "\t_stack = deque()",
            "",
            "\tdef __init__(self):",
            "\t\tpass",
            "",
            "\tdef push(self, a1):",
            "\t\tself._stack.append(a1)",
            "\t",
            "\tdef pop(self):",
            "\t\tif(not self.empty()):",
            "\t\t\treturn self._stack.pop()",
            "\t\telse:",
            "\t\t\treturn None",
            "",
            "\tdef show(self):",
            "\t\treturn list(self._stack)",
            "   ",
            "\tdef is_empty(self):",
            "\t\treturn True if len(self._stack) == 0 else False",
            "\t",
            "\tdef size(self):",
            "\t\treturn len(self._stack)",
            "\t",
            "\tdef peek(self):",
            "\t\treturn self._stack[len(self._stack)-1]",
            "\t",
            "\tdef empty(self):",
            "\t\tself._stack.clear()",
            "",
            "s1 = stack()",
            "s1.push('a')",
            "print(s1.size())",
            "print(s1.peek())",
            "print(s1.show())",
            "print(s1.is_empty())",
            "print(s1.pop())",
            "print(s1.empty())"
        ]
    },
	"create queue class": {
        "prefix": "create queue, queue class, queue obj, create queue class",
        "body": [
            "# implementing queue",
            "from collections import deque",
            "# close this queue class from side",
            "class queue:",
            "\t_queue = deque()",
            "  ",
            "\tdef __init__(self):",
            "\t\tpass",
            "  ",
            "\tdef enqueue(self, a1):",
            "\t\tself._queue.append(a1)",
            "\t  ",
            "\tdef dequeue(self):",
            "\t\treturn self._queue.popleft()",
            "  ",
            "\tdef show(self):",
            "\t\treturn list(self._queue)",
            "  ",
            "q1 = queue()",
            "q1.enqueue('a')",
            "print(q1.show())",
            "print(q1.dequeue())"
        ]
    },
	"linked list class": {
        "prefix": "llist, linked list, linkedlist, linked list class, linked list class obj, linked list obj",
        "body": [
            "# implementing linked list",
            "class Node:",
            "\tdef __init__(self, data=None):",
            "\t\tself.data = data",
            "\t\tself.next = None",
            "# close this class from side",
            "class linkedList:",
            "\t_list = []",
            "",
            "\tdef __init__(self):",
            "\t\tself.head = None",
            "",
            "\tdef insert(self, newdata, direction = \"end\", location = 0):",
            "\t\tif direction == \"end\":",
            "\t\t\tNewNode = Node(newdata)",
            "\t\t\tif self.head is None:",
            "\t\t\t\tself.head = NewNode",
            "\t\t\t\treturn",
            "\t\t\tlast = self.head",
            "\t\t\twhile(last.next):",
            "\t\t\t\tlast = last.next",
            "\t\t\tlast.next=NewNode",
            "\t\telif direction == \"start\":",
            "\t\t\tNewNode = Node(newdata)",
            "\t\t\tNewNode.next = self.head",
            "\t\t\tself.head = NewNode",
            "\t\telif direction == \"between\":",
            "\t\t\tnode = list.head",
            "\t\t\twhile(location != 0):",
            "\t\t\t\tnode = node.next",
            "\t\t\t\tlocation -= 1",
            "\t\t\tif node is None:",
            "\t\t\t\tprint(\"The mentioned node is absent\")",
            "\t\t\t\treturn",
            "\t\t\tNewNode = Node(newdata)",
            "\t\t\tNewNode.next = node.next",
            "\t\t\tnode.next = NewNode",
            "\t\t",
            "\tdef remove(self, Removekey):",
            "\t\tHeadVal = self.head",
            "\t ",
            "\t\tif (HeadVal is not None):",
            "\t\t\tif (HeadVal.data == Removekey):",
            "\t\t\t\tself.head = HeadVal.next",
            "\t\t\t\tHeadVal = None",
            "\t\t\t\treturn",
            "\t\twhile (HeadVal is not None):",
            "\t\t\tif HeadVal.data == Removekey:",
            "\t\t\t\tbreak",
            "\t\t\tprev = HeadVal",
            "\t\t\tHeadVal = HeadVal.next",
            "",
            "\t\tif (HeadVal == None):",
            "\t\t\treturn",
            "",
            "\t\tprev.next = HeadVal.next",
            "\t\tHeadVal = None",
            "",
            "\tdef show(self):",
            "\t\tself._list = []",
            "\t\tprintval = self.head",
            "\t\twhile printval is not None:",
            "\t\t\tself._list.append(printval.data)",
            "\t\t\tprintval = printval.next",
            "\t\tprint(self._list)",
            "",
            "\tdef size(self):",
            "\t\tcount = 0",
            "\t\tprintval = self.head",
            "\t\twhile printval is not None:",
            "\t\t\tcount += 1",
            "\t\t\tprintval = printval.next",
            "\t\treturn count",
            "\t  ",
            "\tdef detectLoop(self):",
            "\t\ts = set()",
            "\t\ttemp = self.head",
            "\t\twhile (temp):",
            "\t\t\tif (temp in s):",
            "\t\t\t\treturn True",
            "\t\t\ts.add(temp)",
            "\t\t\ttemp = temp.next",
            "\t\treturn False",
            "",
            "\tdef clear(self):",
            "\t\twhile (self.head != None):",
            "\t\t\ttemp = self.head",
            "\t\t\tself.head = self.head.next",
            "\t\t\ttemp = None",
            "\t\t",
            "list = linkedList()",
            "list.insert(5)",
            "list.insert(10, \"start\")",
            "list.insert(6, \"between\", 1)",
            "list.show()",
            "list.remove(5)",
            "print(list.detectLoop())",
            "list.clear()",
            "list.insert(9)",
            "print(list.size())"
        ]
    },
	"method overriding example": {
        "prefix": "method overriding, how to method override, method override with multiple inheritance, multiple inheritance",
        "body": [
            "# method overriding",
            "class c1():",
            "\tdef __init__(self):",
            "\t\tprint(\"c1\")",
            "\t\tself.cal1()",
            "  ",
            "\tdef cal1(self):",
            "\t\tprint(\">>c1\")",
            "",
            "class c3():",
            "\tdef __init__(self):",
            "\t\tprint(\"c3\")",
            "\t\tself.cal1()",
            "\t  ",
            "\tdef cal1(self):",
            "\t\tprint(\">>c3\")",
            "",
            "class c2(c1, c3):",
            "\tdef __init__(self):",
            "\t\tc1.__init__(self)",
            "\t\tc3.__init__(self)",
            "\t\tprint(\"c2\")",
            "\t\tself.cal1()",
            "\t",
            "\tdef cal1(self):",
            "\t\tprint(\">>c2\")"
        ]
    },
	"pretty print dictionary method": {
        "prefix": "pretty print, pretty print a dictionary, print dictionary",
        "body": [
            "# method to pretty print dictionary",
            "import json",
            "def pprint(d1):",
            "\tif type(d1) == dict:",
            "\t\tprint(json.dumps(d1, sort_keys=False, indent=4))",
            "\telse:",
            "\t\tprint(json.dumps(dict(d1), sort_keys=False, indent=4))"
        ]
    },
	"get response from http link": {
        "prefix": "get response from http link, https link, request link, request https link, get response from web",
        "body": [
            "# get response from http link, https",
            "import requests",
            "r =requests.get('${1:enter link here}')",
            "print(r.text)",
            "print(r.url)",
            "print(r.status_code)",
            "print(\"\\n\\n\", r.json)",
            "print(\"\\n\\n\", str(r.content))",
            "print(\"\\n\\n\", r.headers)"
        ]
    },
	"read txt file from https": {
        "prefix": "requests txt file from https, read txt from link, read txt from https, print lines from https link",
        "body": [
            "# read txt file from web, https",
            "import urllib, requests",
            "lines = urllib.request.urlopen(\"http://www.google.com\").read()",
            "for line in lines:",
            "\tprint(line)"
        ]
    },
	"read json from api link": {
        "prefix": "read json from https, read dict from https, read json from api, read json into dict from api, read json into dict",
        "body": [
            "# read api json data from web with expand, https",
            "import urllib.request, json ",
            "with urllib.request.urlopen(\"${1: api link here}\") as url:",
            "\tdata = json.loads(url.read().decode())",
            "\tprint(data['status'])"
        ]
    },
	"encapsulation: static variable": {
        "prefix": "static variable class, static class, class with static variable",
        "body": [
            "# class with a static variable",
            "class c1():",
            "\tj = 0",
            "   ",
            "\tdef __init__(self):",
            "\t\tc1.j = 0",
            "   ",
            "\tdef m1(self):",
            "\t\tc1.j += 1",
            ""
        ]
    },
	"Encapsulation: Non-static variable": {
        "prefix": "class with non-static variable, non-static variable, non static var",
        "body": [
            "# class with a non-static variable",
            "class c1():",
            "\tdef __init__(self):",
            "\t\tself.j = 0",
            "   ",
            "\tdef m1(self):",
            "\t\tself.j += 1",
            ""
        ]
    },
	"Encapsulation: Private variable": {
        "prefix": "class with private variable, private variable, class with private var",
        "body": [
            "# class with a non-static private variable",
            "class c1():",
            "\tdef __init__(self):",
            "\t\tself.__j = 0",
            "   ",
            "\tdef m1(self):",
            "\t\tself.__j += 1",
            ""
        ]
    },
	"design patterns": {
        "prefix": "Python design patterns",
        "body": [
            "# /////////////////////// DESIGN PATTERNS ///////////////////  ",
            "# BEHAVIOURAL PATTERN//////////////////////////////////",
            "# iterator pattern",
            "#   - list, dictionary, string",
            "# chain of responsibility pattern",
            "#   - class passed with method names",
            "# command pattern",
            "#   - give execution command to another class like history class",
            "#",
            "# CREATIONAL PATTERN//////////////////////////////////",
            "# singleton pattern",
            "#   - create only one instance of class in whole lifetime",
            "# abstract factory",
            "#   - create abstract classes before use",
            "# ",
            "# STRUCTURAL PATTERN//////////////////////////////////",
            "# facade",
            "#   - when you have too many objects using same class objects, you can put them in another class called facade",
            "# adapter",
            "#   - create a adpapter class that extends adaptee functionality and then calls its extended method by self.m1()"
        ]
    },
	"Chain of responsibility design pattern": {
        "prefix": "design pattern - chain of responsibility",
        "body": [
            "# chain of responsibility design pattern",
            "class chain():",
            "\tdef __init__(self, resp_list):",
            "\t   ",
            "\t\tself._responsibilities = []",
            "\t   ",
            "\t\tif resp_list is not None:",
            "\t\t\tself._responsibilities += resp_list",
            "",
            "\tdef start(self):",
            "\t\tfor responsibility in self._responsibilities:",
            "\t\t\tresponsibility()",
            "",
            "def resp1():",
            "\tprint(i)",
            "  ",
            "def resp2():",
            "\tprint(i+1)",
            "  ",
            "def resp3():",
            "\tprint(i+2)",
            "",
            "chain = chain([resp1,resp2,resp3])",
            "i = 0",
            "chain.start()"
        ]
    },
	"Command Pattern": {
        "prefix": "Design Pattern - Command, Design Pattern - Agent",
        "body": [
            "# command pattern",
            "class person():",
            "\tdef __init__(self, a1):",
            "\t\tself._name = a1",
            "",
            "\tdef kill(self):",
            "\t\tprint(\"killed\")",
            "",
            "\tdef alive(self):",
            "\t\tprint(\"alived\")",
            "",
            "class agent():",
            "\tdef __init__(self):",
            "\t\tself._personsKilled = list()",
            "",
            "\tdef call(self, person):",
            "\t\tself._personsKilled.append(person)",
            "\t\tperson.kill()",
            "",
            "\tdef undo(self):",
            "\t\tlast_person_killed = self._personsKilled.pop()",
            "\t\tlast_person_killed.alive()",
            "\t  ",
            "agent = agent()",
            "person = person('kainat')",
            "agent.call(person)",
            "agent.undo()"
        ]
    },
	"Iterator Design Pattern": {
        "prefix": "Design Pattern - Iterator",
        "body": [
            "# iterator design pattern",
            "class sumTillN():",
            "\tdef __init__(self, n):",
            "\t\tself.sum = 0",
            "\t\tself._n = n",
            "\t   ",
            "\tdef __iter__(self):",
            "\t\tself._i = 0",
            "\t\treturn self",
            "\t   ",
            "\tdef __next__(self):",
            "\t\tif(self._i < self._n):",
            "\t\t\tself.sum += self._i",
            "\t\t\tself._i+=1",
            "\t\t\treturn self.sum",
            "\t\telse:",
            "\t\t\traise StopIteration",
            "   ",
            "for i in sumTillN(10):",
            "\tprint(i) "
        ]
    },
	"Singleton Design Pattern": {
        "prefix": "Design pattern - Singleton",
        "body": [
            "# singleton design pattern",
            "class A():",
            "\tinstance_1_done = False",
            "   ",
            "\tdef __init__(self):",
            "\t\tif(not A.instance_1_done):",
            "\t\t\tA.instance_1_done = True\t\t",
            "\t\telse:",
            "\t\t\traise OverflowError",
            "",
            "s1 = A()"
        ]
    }

}